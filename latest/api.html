<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · SimJulia.jl documentation</title><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>SimJulia.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Intro</span><ul><li><a class="toctext" href="10_min/1_installation.html">Installation</a></li><li><a class="toctext" href="10_min/2_basic_concepts.html">Basic Concepts</a></li><li><a class="toctext" href="10_min/3_process_interaction.html">Process Interaction</a></li></ul></li><li><a class="toctext" href="topics.html">Manual</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/1_bank_renege.html">Bank Renege</a></li></ul></li><li class="current"><a class="toctext" href="api.html">Library</a><ul class="internal"><li><a class="toctext" href="#Public-1">Public</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">Library</a></li></ul><a class="edit-page" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Public-1" href="#Public-1">Public</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia" href="#SimJulia"><code>SimJulia</code></a> — <span class="docstring-category">Module</span>.</div><div><p><code>SimJulia</code></p><p>Main module for SimJulia.jl – a combined continuous time / discrete event process oriented simulation framework for Julia.</p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/SimJulia.jl#L3-L7">source</a><br/></section><h3><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia.AbstractEvent" href="#SimJulia.AbstractEvent"><code>SimJulia.AbstractEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The parent type for all events.</p><p>An events holds a pointer to an instance of a subtype of <code>Environment</code>.</p><p>An event has a state:</p><ul><li><p>may happen (idle),</p></li><li><p>is going to happen (scheduled),</p></li><li><p>has happened (triggered).</p></li></ul><p>Once the events is scheduled, it has a value.</p><p>An event has also a list of callbacks. A callback can be any function as long as it accepts an instance of a subtype of <code>AbstractEvent</code> as its first argument. Once an event gets triggered, all callbacks will be invoked. Callbacks can do further processing with the value it has produced.</p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/base.jl#L3-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia.Timeout" href="#SimJulia.Timeout"><code>SimJulia.Timeout</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An event that gets triggered after a delay has passed.</p><p>This event is automatically scheduled when it is created.</p><p><strong>Signature</strong>:</p><p>Timeout{E&lt;:Environment} &lt;: AbstractEvent{E}</p><p><strong>Field</strong>:</p><ul><li><p><code>bev :: BaseEvent{E}</code></p></li></ul><p><strong>Constructors</strong>:</p><ul><li><p><code>Timeout{E&lt;:Environment}(env::E, delay::Period; priority::Bool=false, value::Any=nothing) :: Timeout{E}</code></p></li><li><p><code>Timeout{E&lt;:Environment}(env::E, delay::Number=0; priority::Bool=false, value::Any=nothing) :: Timeout{E}</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/events.jl#L25-L42">source</a><br/></section><h3><a class="nav-anchor" id="Simulation-1" href="#Simulation-1">Simulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia.Simulation" href="#SimJulia.Simulation"><code>SimJulia.Simulation</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Execution environment for a simulation.</p><p>The passing of time is implemented by stepping from event to event.</p><p><strong>Signature</strong>: Simulation{T&lt;:TimeType} &lt;: Environment</p><p><strong>Fields</strong>:</p><ul><li><p><code>time :: T</code></p></li><li><p><code>heap :: PriorityQueue{BaseEvent{Simulation{T}}, EventKey{T}}</code></p></li><li><p><code>eid :: UInt</code></p></li><li><p><code>sid :: UInt</code></p></li><li><p><code>active_proc :: Nullable{Process}</code></p></li></ul><p><strong>Constructors</strong>:</p><ul><li><p><code>Simulation{T&lt;:TimeType}(initial_time::T) :: Simulation{T}</code></p></li><li><p><code>Simulation(initial_time::Number=0) :: Simulation{SimulationTime}</code></p></li></ul><p>An initial_time for the simulation can be specified. By default, it starts at 0.</p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/simulation.jl#L11-L33">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Dates.now-Tuple{SimJulia.Simulation{T<:Base.Dates.TimeType}}" href="#Base.Dates.now-Tuple{SimJulia.Simulation{T<:Base.Dates.TimeType}}"><code>Base.Dates.now</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the current simulation time.</p><p><strong>Method</strong>: <code>now{T&lt;:TimeType}(sim::Simulation{T}) :: T</code></p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/simulation.jl#L53-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.run-Tuple{SimJulia.Simulation{T<:Base.Dates.TimeType},SimJulia.AbstractEvent{SimJulia.Simulation{T<:Base.Dates.TimeType}}}" href="#Base.run-Tuple{SimJulia.Simulation{T<:Base.Dates.TimeType},SimJulia.AbstractEvent{SimJulia.Simulation{T<:Base.Dates.TimeType}}}"><code>Base.run</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Executes <a href="api.html#SimJulia.step-Tuple{SimJulia.Simulation}"><code>step</code></a> until the given criterion is met:</p><ul><li><p>if nothing is not specified, the method will return when there are no further events to be triggered</p></li><li><p>if it is a subtype of <code>AbstractEvent</code>, the simulation will continue stepping until this event has been triggered and will return its value</p></li><li><p>if it is a subtype of <code>TimeType</code>, the simulation will continue stepping until the simulation’s time reaches until</p></li><li><p>if it is a subtype of <code>Period</code>, the simulation will continue stepping during the given period</p></li><li><p>if it is a subtype of <code>Number</code>, the method will continue stepping during a period of elementary time units</p></li></ul><p>In the first two cases, the simulation can prematurely stop when there are no further events to be triggered.</p><p>If the stepping end with a <code>StopSimulation</code> exception the function return the value of the exception, in all other cases the exception is rethrown.</p><p><strong>Methods</strong>:</p><ul><li><p><code>run(sim::Simulation, until::AbstractEvent) :: Any</code></p></li><li><p><code>run{T&lt;:TimeType}(sim::Simulation{T}, until::T) :: Any</code></p></li><li><p><code>run(sim::Simulation, period::Union{Period, Number}) :: Any</code></p></li><li><p><code>run(sim::Simulation) :: Any</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/simulation.jl#L108-L127">source</a><br/></section><h3><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia.Process" href="#SimJulia.Process"><code>SimJulia.Process</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>Process</code> is an abstraction for an event yielding function, i.e. a process function.</p><p>The process function can suspend its execution by yielding an instance of <code>AbstractEvent</code>. The <code>Environment</code> will take care of resuming the process function with the value of that event once it has happened. The exception of failed events is also thrown into the process function.</p><p>A <code>Process</code> is a subtype of <code>AbstractEvent</code>. It is triggered, once the process functions returns or raises an exception. The value of the process is the return value of the process function or the exception, respectively.</p><p><strong>Signature</strong>:</p><p>Process{E&lt;:Environment} &lt;: AbstractEvent{E}</p><p><strong>Fields</strong>:</p><ul><li><p><code>bev :: BaseEvent{E}</code></p></li><li><p><code>task :: Task</code></p></li><li><p><code>target :: AbstractEvent{E}</code></p></li><li><p><code>resume :: Function</code></p></li></ul><p><strong>Constructor</strong>:</p><p>Process{E&lt;:Environment}(func::Function, env::E, args::Any...) :: Process{E}</p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/process.jl#L1-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.yield-Tuple{SimJulia.AbstractEvent}" href="#Base.yield-Tuple{SimJulia.AbstractEvent}"><code>Base.yield</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Passes the control flow back to the simulation. If the yielded event is triggered, the <code>Environment</code> will resume the function after this statement.</p><p>The return value is the value from the yielded event.</p><p><strong>Method</strong>:</p><p>yield(target::AbstractEvent) :: Any</p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/process.jl#L56-L64">source</a><br/></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><h3><a class="nav-anchor" id="Simulation-2" href="#Simulation-2">Simulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SimJulia.step-Tuple{SimJulia.Simulation}" href="#SimJulia.step-Tuple{SimJulia.Simulation}"><code>SimJulia.step</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Does a simulation step and processes the next event.</p><p><strong>Method</strong>:</p><p><code>step(sim::Simulation) :: Bool</code></p></div><a class="source-link" target="_blank" href="https://github.com/BenLauwens/SimJulia.jl/tree/da865b575d4afd36b7850e712723927d92be5794/src/simulation.jl#L88-L94">source</a><br/></section><footer><hr/><a class="previous" href="examples/1_bank_renege.html"><span class="direction">Previous</span><span class="title">Bank Renege</span></a></footer></article></body></html>
