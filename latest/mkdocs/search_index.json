{
    "docs": [
        {
            "location": "/", 
            "text": "SimJulia.jl\n\n\nSimJulia\n is a combined continuous time / discrete event process oriented simulation framework written in \nJulia\n inspired by the Simula library \nDISCO\n and the Python library \nSimPy\n.\n\n\n\n\n\n\nAuthors\n\n\n\n\nBen Lauwens\n, Royal Military Academy, Brussels, Belgium\n\n\n\n\n\n\nLicense\n\n\nSimJulia is licensed under the \nMIT \"Expat\" license\n.\n\n\n\n\nInstallation\n\n\nSimJulia.jl is a \nregistered package\n, and is simply installed by running\n\n\njulia\n Pkg.add(\nSimJulia\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#simjuliajl", 
            "text": "SimJulia  is a combined continuous time / discrete event process oriented simulation framework written in  Julia  inspired by the Simula library  DISCO  and the Python library  SimPy .", 
            "title": "SimJulia.jl"
        }, 
        {
            "location": "/#authors", 
            "text": "Ben Lauwens , Royal Military Academy, Brussels, Belgium", 
            "title": "Authors"
        }, 
        {
            "location": "/#license", 
            "text": "SimJulia is licensed under the  MIT \"Expat\" license .", 
            "title": "License"
        }, 
        {
            "location": "/#installation", 
            "text": "SimJulia.jl is a  registered package , and is simply installed by running  julia  Pkg.add( SimJulia )", 
            "title": "Installation"
        }, 
        {
            "location": "/intro/", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/topics/", 
            "text": "", 
            "title": "Topical guides"
        }, 
        {
            "location": "/examples/", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/api/", 
            "text": "API\n\n\n\n\nPublic\n\n\n#\n\n\nSimJulia\n \n \nModule\n.\n\n\nSimJulia\n\n\nMain module for SimJulia.jl \u2013 a combined continuous time / discrete event process oriented simulation framework for Julia.\n\n\nsource\n\n\n\n\nEvents\n\n\n#\n\n\nSimJulia.EVENT_IDLE\n \n \nConstant\n.\n\n\nconst EVENT_IDLE\n\n\nState representing an event that may happen but is not yet scheduled.\n\n\nsource\n\n\n#\n\n\nSimJulia.EVENT_PROCESSING\n \n \nConstant\n.\n\n\nconst EVENT_PROCESSING\n\n\nState representing an event that is happening.\n\n\nsource\n\n\n#\n\n\nSimJulia.EVENT_TRIGGERED\n \n \nConstant\n.\n\n\nconst EVENT_TRIGGERED\n\n\nState representing an event that is going to happen, i.e. is scheduled but processing has not yet been started.\n\n\nsource\n\n\n#\n\n\nSimJulia.Event\n \n \nType\n.\n\n\nEvent\n\n\nAn event is a state machine with three states:\n\n\n\n\nEVENT_IDLE\n\n\nEVENT_TRIGGERED\n\n\nEVENT_PROCESSING\n\n\n\n\nOnce the processing has ended, the event returns to an \nEVENT_IDLE\n state and can be scheduled again.\n\n\nAn event is initially not triggered. Events are scheduled for processing by the simulation after they are triggered.\n\n\nAn event has a list of callbacks and a value. A callback can be any function. Once an event gets processed, all callbacks will be invoked. Callbacks can do further processing with the value it has produced.\n\n\nFailed events, i.e. events having as value an \nException\n, are never silently ignored and will raise this exception upon being processed.\n\n\nFields:\n\n\n\n\ncallbacks :: Vector{Function}\n\n\nstate :: UInt\n\n\nvalue :: Any\n\n\n\n\nConstructor:\n\n\n\n\nEvent()\n\n\nEvent(sim::Simulation, delay::Float64; priority::Bool=false, value::Any=nothing)\n\n\n\n\nsource\n\n\n#\n\n\nSimJulia.state\n \n \nMethod\n.\n\n\nstate(ev::Event) :: EventState\n\n\nReturns the state of the event.\n\n\nsource\n\n\n#\n\n\nSimJulia.value\n \n \nMethod\n.\n\n\nvalue(ev::Event) :: Any\n\n\nReturns the value of the event.\n\n\nsource\n\n\n\n\nSimulation\n\n\n#\n\n\nSimJulia.Simulation\n \n \nType\n.\n\n\nSimulation\n\n\nExecution environment for a simulation. The passing of time is implemented by stepping from event to event.\n\n\nFields\n:\n\n\n\n\ntime :: Float64\n\n\nheap :: PriorityQueue{Event, EventKey}\n\n\nsid :: UInt\n\n\n\n\nConstructor\n:\n\n\nSimulation(initial_time::Float64=0.0)\n\n\nAn initial_time for the simulation can be specified. By default, it starts at 0.0.\n\n\nsource\n\n\n#\n\n\nSimJulia.StopSimulation\n \n \nType\n.\n\n\nStopSimulation \n: Exception\n\n\nException that stops the simulation. A return value can be set.\n\n\nFields\n:\n\n\n\n\nvalue :: Any\n\n\n\n\nConstructor\n:\n\n\nStopSimulation(value::Any=nothing)\n\n\nsource\n\n\n#\n\n\nBase.Dates.now\n \n \nMethod\n.\n\n\nnow(sim::Simulation) :: Float64\n\n\nReturns the current simulation time.\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\n\n\nrun(sim::Simulation, until::Event)\n\n\nrun(sim::Simulation, until::Float64)\n\n\nrun(sim::Simulation)\n\n\n\n\nExecutes \nstep\n until the given criterion \nuntil\n is met:\n\n\n\n\nif it is not specified, the method will return when there are no further events to be processed\n\n\nif it is an \nEvent\n, the method will continue stepping until this event has been triggered and will return its value\n\n\nif it is a \nFloat64\n, the method will continue stepping until the environment\u2019s time reaches until\n\n\n\n\nIn the last two cases, the simulation can prematurely stop when there are no further events to be processed.\n\n\nsource\n\n\n#\n\n\nSimJulia.append_callback\n \n \nMethod\n.\n\n\nappend_callback(ev::Event, cb::Function, args...)\n\n\nAdds a callback function to the event. Optional arguments to the callback function can be specified by \nargs...\n. If the event is being processed an \nEventProcessing\n exception is thrown.\n\n\nCallback functions are called in order of adding to the event.\n\n\nsource\n\n\n\n\nProcesses\n\n\n\n\nContinuous\n\n\n\n\nResources\n\n\n\n\nInternals\n\n\n#\n\n\nSimJulia.EventKey\n \n \nType\n.\n\n\nEventKey\n\n\nKey for the event heap.\n\n\nFields\n:\n\n\n\n\ntime :: Float64\n\n\npriority :: Bool\n\n\nid :: UInt\n\n\n\n\nConstructor\n:\n\n\nEventKey(time :: Float64, priority :: Bool, id :: UInt\n)\n\n\nOnly used internally.\n\n\nsource\n\n\n#\n\n\nSimJulia.EventNotIdle\n \n \nType\n.\n\n\nEventNotIdle \n: Exception\n\n\nException thrown when an event is scheduled (\nschedule\n)  that has already been scheduled or is being processed.\n\n\nOnly used internally.\n\n\nsource\n\n\n#\n\n\nSimJulia.EventProcessing\n \n \nType\n.\n\n\nEventProcessing \n: Exception\n\n\nException thrown:\n\n\n\n\nwhen a callback is added to an event (\nappend_callback\n) that is being processed or\n\n\nwhen an event is scheduled (\nschedule!\n) that is being processed.\n\n\n\n\nOnly used internally.\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::EventKey, b::EventKey) :: Bool\n\n\nCompairs two \nEventKey\n. The criteria in order of importance are:\n\n\n\n\ntime of processing\n\n\npriority when time of processing is equal\n\n\nscheduling id, i.e. the event that was first scheduled is first processed when time of processing and priority are identical\n\n\n\n\nOnly used internally.\n\n\nsource\n\n\n#\n\n\nBase.schedule\n \n \nMethod\n.\n\n\nschedule(sim::Simulation, ev::Event, delay::Float64=0.0; priority::Bool=false, value::Any=nothing) :: Event\n\n\nSchedules an event at time \nsim.time + delay\n with a \npriority\n and a \nvalue\n.\n\n\nIf the event is already scheduled or is beign processed, an \nEventNotIdle\n exception is thrown.\n\n\nsource\n\n\n#\n\n\nSimJulia.schedule!\n \n \nMethod\n.\n\n\nschedule!(sim::Simulation, ev::Event, delay::Float64=0.0; priority::Bool=false, value::Any=nothing) :: Event\n\n\nSchedules an event at time \nsim.time + delay\n with a \npriority\n and a \nvalue\n.\n\n\nIf the event is already scheduled, the key is updated with the new \ndelay\n and \npriority\n. The new \nvalue\n is also set.\n\n\nIf the event is being processed, an \nEventProcessing\n exception is thrown.\n\n\nsource\n\n\n#\n\n\nSimJulia.step\n \n \nMethod\n.\n\n\nstep(sim::Simulation) :: Bool\n\n\nDoes a simulation step and processes the next event.\n\n\nOnly used internally.\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/api/#public", 
            "text": "#  SimJulia     Module .  SimJulia  Main module for SimJulia.jl \u2013 a combined continuous time / discrete event process oriented simulation framework for Julia.  source", 
            "title": "Public"
        }, 
        {
            "location": "/api/#events", 
            "text": "#  SimJulia.EVENT_IDLE     Constant .  const EVENT_IDLE  State representing an event that may happen but is not yet scheduled.  source  #  SimJulia.EVENT_PROCESSING     Constant .  const EVENT_PROCESSING  State representing an event that is happening.  source  #  SimJulia.EVENT_TRIGGERED     Constant .  const EVENT_TRIGGERED  State representing an event that is going to happen, i.e. is scheduled but processing has not yet been started.  source  #  SimJulia.Event     Type .  Event  An event is a state machine with three states:   EVENT_IDLE  EVENT_TRIGGERED  EVENT_PROCESSING   Once the processing has ended, the event returns to an  EVENT_IDLE  state and can be scheduled again.  An event is initially not triggered. Events are scheduled for processing by the simulation after they are triggered.  An event has a list of callbacks and a value. A callback can be any function. Once an event gets processed, all callbacks will be invoked. Callbacks can do further processing with the value it has produced.  Failed events, i.e. events having as value an  Exception , are never silently ignored and will raise this exception upon being processed.  Fields:   callbacks :: Vector{Function}  state :: UInt  value :: Any   Constructor:   Event()  Event(sim::Simulation, delay::Float64; priority::Bool=false, value::Any=nothing)   source  #  SimJulia.state     Method .  state(ev::Event) :: EventState  Returns the state of the event.  source  #  SimJulia.value     Method .  value(ev::Event) :: Any  Returns the value of the event.  source", 
            "title": "Events"
        }, 
        {
            "location": "/api/#simulation", 
            "text": "#  SimJulia.Simulation     Type .  Simulation  Execution environment for a simulation. The passing of time is implemented by stepping from event to event.  Fields :   time :: Float64  heap :: PriorityQueue{Event, EventKey}  sid :: UInt   Constructor :  Simulation(initial_time::Float64=0.0)  An initial_time for the simulation can be specified. By default, it starts at 0.0.  source  #  SimJulia.StopSimulation     Type .  StopSimulation  : Exception  Exception that stops the simulation. A return value can be set.  Fields :   value :: Any   Constructor :  StopSimulation(value::Any=nothing)  source  #  Base.Dates.now     Method .  now(sim::Simulation) :: Float64  Returns the current simulation time.  source  #  Base.run     Function .   run(sim::Simulation, until::Event)  run(sim::Simulation, until::Float64)  run(sim::Simulation)   Executes  step  until the given criterion  until  is met:   if it is not specified, the method will return when there are no further events to be processed  if it is an  Event , the method will continue stepping until this event has been triggered and will return its value  if it is a  Float64 , the method will continue stepping until the environment\u2019s time reaches until   In the last two cases, the simulation can prematurely stop when there are no further events to be processed.  source  #  SimJulia.append_callback     Method .  append_callback(ev::Event, cb::Function, args...)  Adds a callback function to the event. Optional arguments to the callback function can be specified by  args... . If the event is being processed an  EventProcessing  exception is thrown.  Callback functions are called in order of adding to the event.  source", 
            "title": "Simulation"
        }, 
        {
            "location": "/api/#processes", 
            "text": "", 
            "title": "Processes"
        }, 
        {
            "location": "/api/#continuous", 
            "text": "", 
            "title": "Continuous"
        }, 
        {
            "location": "/api/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/api/#internals", 
            "text": "#  SimJulia.EventKey     Type .  EventKey  Key for the event heap.  Fields :   time :: Float64  priority :: Bool  id :: UInt   Constructor :  EventKey(time :: Float64, priority :: Bool, id :: UInt )  Only used internally.  source  #  SimJulia.EventNotIdle     Type .  EventNotIdle  : Exception  Exception thrown when an event is scheduled ( schedule )  that has already been scheduled or is being processed.  Only used internally.  source  #  SimJulia.EventProcessing     Type .  EventProcessing  : Exception  Exception thrown:   when a callback is added to an event ( append_callback ) that is being processed or  when an event is scheduled ( schedule! ) that is being processed.   Only used internally.  source  #  Base.isless     Method .  isless(a::EventKey, b::EventKey) :: Bool  Compairs two  EventKey . The criteria in order of importance are:   time of processing  priority when time of processing is equal  scheduling id, i.e. the event that was first scheduled is first processed when time of processing and priority are identical   Only used internally.  source  #  Base.schedule     Method .  schedule(sim::Simulation, ev::Event, delay::Float64=0.0; priority::Bool=false, value::Any=nothing) :: Event  Schedules an event at time  sim.time + delay  with a  priority  and a  value .  If the event is already scheduled or is beign processed, an  EventNotIdle  exception is thrown.  source  #  SimJulia.schedule!     Method .  schedule!(sim::Simulation, ev::Event, delay::Float64=0.0; priority::Bool=false, value::Any=nothing) :: Event  Schedules an event at time  sim.time + delay  with a  priority  and a  value .  If the event is already scheduled, the key is updated with the new  delay  and  priority . The new  value  is also set.  If the event is being processed, an  EventProcessing  exception is thrown.  source  #  SimJulia.step     Method .  step(sim::Simulation) :: Bool  Does a simulation step and processes the next event.  Only used internally.  source", 
            "title": "Internals"
        }
    ]
}