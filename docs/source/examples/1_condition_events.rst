Condition events
----------------


Bank Renege
~~~~~~~~~~~

Covers:

- Resources: :class:`Resource`
- Condition events

A counter with a random service time and customers who renege.

This example models a bank counter and customers arriving at random times. Each customer has a certain patience. It waits to get to the counter until she’s at the end of her tether. If she gets to the counter, she uses it for a while before releasing it.

New customers are created by the source process every few time steps.

.. code-block:: julia

  using SimJulia
  using Distributions

  const RANDOM_SEED = 150
  const NEW_CUSTOMERS = 5  # Total number of customers
  const INTERVAL_CUSTOMERS = 10.0  # Generate new customers roughly every x seconds
  const MIN_PATIENCE = 1.0  # Min. customer patience
  const MAX_PATIENCE = 3.0  # Max. customer patience

  function source(env::BaseEnvironment, number::Int64, interval::Float64, counter::Resource)
    d = Exponential(interval)
    for i in 1:number
      Process(env, customer, "Customer$i", counter, 12.0)
      yield(Timeout(env, rand(d)))
    end
  end

  function customer(env::BaseEnvironment, name::ASCIIString, counter::Resource, time_in_bank::Float64)
    arrive = now(env)
    println("$arrive $name: Here I am")
    req = Request(counter)
    patience = rand(Uniform(MIN_PATIENCE, MAX_PATIENCE))
    result = yield(req | Timeout(env, patience))
    wait = now(env) - arrive
    if in(req, keys(result))
      println("$(now(env)) $name: Waited $wait")
      yield(Timeout(env, rand(Exponential(time_in_bank))))
      println("$(now(env)) $name: Finished")
    else
      println("$(now(env)) $name: RENEGED after $wait")
    end
    yield(Release(counter))
  end

  # Setup and start the simulation
  println("Bank renege")
  srand(RANDOM_SEED)
  env = Environment()

  # Start processes and run
  counter = Resource(env, 1)
  Process(env, source, NEW_CUSTOMERS, INTERVAL_CUSTOMERS, counter)
  run(env)

The simulation’s output::

  Bank renege
  0.0 Customer1: Here I am
  0.0 Customer1: Waited 0.0
  4.435484832567573 Customer1: Finished
  21.013085103081753 Customer2: Here I am
  21.013085103081753 Customer2: Waited 0.0
  23.097746900916643 Customer3: Here I am
  23.91170855317896 Customer2: Finished
  23.91170855317896 Customer3: Waited 0.8139616522623179
  30.113622311091923 Customer4: Here I am
  30.621135918022613 Customer5: Here I am
  32.43509581615485 Customer5: RENEGED after 1.8139598981322358
  32.63868913452709 Customer3: Finished
  32.63868913452709 Customer4: Waited 2.525066823435168
  35.25594434892944 Customer4: Finished


Movie Renege
~~~~~~~~~~~~

Covers:

- Resources: :class:`Resource`
- Condition events
- Shared events

This examples models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1–6) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue).

The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a :class:`Resource` with a capacity of one.

The moviegoer process function starts waiting until either it’s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less then two tickets are left after the ticket purchase, the sold out signal is triggered.

Moviegoers are generated by the customer arrivals process. It also chooses a movie and the number of tickets for the moviegoer.

.. code-block:: julia

  using SimJulia
  using Distributions
  using Compat

  const RANDOM_SEED = 158
  const TICKETS = 50  # Number of tickets per movie
  const SIM_TIME = 120.0  # Simulate until

  # Create movie theater
  type Theater
    movies :: Vector{ASCIIString}
    counter :: Resource
    available :: Dict{ASCIIString, Int64}
    sold_out :: Dict{ASCIIString, Event}
    when_sold_out :: Dict{ASCIIString, Float64}
    num_renegers :: Dict{ASCIIString, Int64}
    function Theater(env)
      theater = new()
      theater.movies = ASCIIString["Julia Unchained", "Kill Process", "Pulp Implementation"]
      theater.counter = Resource(env, 1)
      theater.available = @compat Dict("Julia Unchained" => TICKETS, "Kill Process" => TICKETS, "Pulp Implementation" => TICKETS)
      theater.sold_out = @compat Dict("Julia Unchained" => Event(env), "Kill Process" => Event(env), "Pulp Implementation" => Event(env))
      theater.when_sold_out = @compat Dict("Julia Unchained" => typemax(Float64), "Kill Process" => typemax(Float64), "Pulp Implementation" => typemax(Float64))
      theater.num_renegers = @compat Dict("Julia Unchained" => 0, "Kill Process" => 0, "Pulp Implementation" => 0)
      return theater
    end
  end

  function moviegoer(env::BaseEnvironment, movie::ASCIIString, num_tickets::Int64, theater::Theater)
    result = yield(Request(theater.counter) | theater.sold_out[movie])
    if in(theater.sold_out[movie], keys(result))
      theater.num_renegers[movie] += 1
    elseif theater.available[movie] < num_tickets
      yield(Timeout(env, 0.5))
    else
      theater.available[movie] -= num_tickets
      if theater.available[movie] < 2
        succeed(theater.sold_out[movie])
        theater.when_sold_out[movie] = now(env)
        theater.available[movie] = 0
      end
      yield(Timeout(env, 1.0))
    end
    yield(Release(theater.counter))
  end

  function customer_arrivals(env::BaseEnvironment, theater::Theater)
    t = Exponential(0.5)
    d = DiscreteUniform(1, 3)
    n = DiscreteUniform(1, 6)
    while true
      yield(Timeout(env, rand(t)))
      movie = theater.movies[rand(d)]
      num_tickets = rand(n)
      if theater.available[movie] > 0
        Process(env, moviegoer, movie, num_tickets, theater)
      end
    end
  end

  # Setup and start the simulation
  println("Movie renege")
  srand(RANDOM_SEED)
  env = Environment()
  theater = Theater(env)

  # Start process and run
  Process(env, customer_arrivals, theater)
  run(env, SIM_TIME)

  # Analysis/results
  for movie in theater.movies
    if processed(theater.sold_out[movie])
      println("Movie $movie sold out $(theater.when_sold_out[movie]) minutes after ticket counter opening.")
      println("  Number of people leaving queue when film sold out: $(theater.num_renegers[movie])")
    end
  end

The simulation’s output::

  Movie renege
  Movie Julia Unchained sold out 47.08786185479453 minutes after ticket counter opening.
    Number of people leaving queue when film sold out: 17
  Movie Kill Process sold out 38.08786185479453 minutes after ticket counter opening.
    Number of people leaving queue when film sold out: 17
  Movie Pulp Implementation sold out 48.08786185479453 minutes after ticket counter opening.
    Number of people leaving queue when film sold out: 10
